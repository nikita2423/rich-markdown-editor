webpackHotUpdate("main",{

/***/ "./src/components/BlockMenu.tsx":
/*!**************************************!*\
  !*** ./src/components/BlockMenu.tsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst capitalize_1 = __importDefault(__webpack_require__(/*! lodash/capitalize */ \"./node_modules/lodash/capitalize.js\"));\nconst react_portal_1 = __webpack_require__(/*! react-portal */ \"./node_modules/react-portal/lib/index.js\");\nconst prosemirror_utils_1 = __webpack_require__(/*! prosemirror-utils */ \"./node_modules/prosemirror-utils/dist/index.js\");\nconst styled_components_1 = __importDefault(__webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.cjs.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types/index.ts\");\nconst BlockMenuItem_1 = __importDefault(__webpack_require__(/*! ./BlockMenuItem */ \"./src/components/BlockMenuItem.tsx\"));\nconst Input_1 = __importDefault(__webpack_require__(/*! ./Input */ \"./src/components/Input.tsx\"));\nconst VisuallyHidden_1 = __importDefault(__webpack_require__(/*! ./VisuallyHidden */ \"./src/components/VisuallyHidden.tsx\"));\nconst getDataTransferFiles_1 = __importDefault(__webpack_require__(/*! ../lib/getDataTransferFiles */ \"./src/lib/getDataTransferFiles.ts\"));\nconst insertFiles_1 = __importDefault(__webpack_require__(/*! ../commands/insertFiles */ \"./src/commands/insertFiles.ts\"));\nconst block_1 = __importDefault(__webpack_require__(/*! ../menus/block */ \"./src/menus/block.ts\"));\nconst SSR = typeof window === \"undefined\";\nclass BlockMenu extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.menuRef = React.createRef();\n        this.inputRef = React.createRef();\n        this.state = {\n            left: -1000,\n            top: 0,\n            bottom: undefined,\n            isAbove: false,\n            selectedIndex: 0,\n            insertItem: undefined,\n        };\n        this.handleKeyDown = (event) => {\n            if (!this.props.isActive)\n                return;\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                event.stopPropagation();\n                const item = this.filtered[this.state.selectedIndex];\n                if (item) {\n                    this.insertItem(item);\n                }\n                else {\n                    this.props.onClose();\n                }\n            }\n            if (event.key === \"ArrowUp\" || (event.ctrlKey && event.key === \"p\")) {\n                event.preventDefault();\n                event.stopPropagation();\n                if (this.filtered.length) {\n                    const prevIndex = this.state.selectedIndex - 1;\n                    const prev = this.filtered[prevIndex];\n                    this.setState({\n                        selectedIndex: Math.max(0, prev && prev.name === \"separator\" ? prevIndex - 1 : prevIndex),\n                    });\n                }\n                else {\n                    this.close();\n                }\n            }\n            if (event.key === \"ArrowDown\" ||\n                event.key === \"Tab\" ||\n                (event.ctrlKey && event.key === \"n\")) {\n                event.preventDefault();\n                event.stopPropagation();\n                if (this.filtered.length) {\n                    const total = this.filtered.length - 1;\n                    const nextIndex = this.state.selectedIndex + 1;\n                    const next = this.filtered[nextIndex];\n                    this.setState({\n                        selectedIndex: Math.min(next && next.name === \"separator\" ? nextIndex + 1 : nextIndex, total),\n                    });\n                }\n                else {\n                    this.close();\n                }\n            }\n            if (event.key === \"Escape\") {\n                this.close();\n            }\n        };\n        this.insertItem = (item) => {\n            switch (item.name) {\n                case \"image\":\n                    return this.triggerImagePick();\n                case \"embed\":\n                    return this.triggerLinkInput(item);\n                case \"link\": {\n                    this.clearSearch();\n                    this.props.onClose();\n                    this.props.onLinkToolbarOpen();\n                    return;\n                }\n                case \"emoji\": {\n                    return this.handleEmojiClick();\n                }\n                case \"mention\": {\n                    return this.handleMentionClick();\n                }\n                default:\n                    this.insertBlock(item);\n            }\n        };\n        this.close = () => {\n            this.props.onClose();\n            this.props.view.focus();\n        };\n        this.handleEmojiClick = () => {\n            const { view, onOpenEmoji } = this.props;\n            const { dispatch, state } = view;\n            const { from, to } = state.selection;\n            const colonText = `:`;\n            dispatch(view.state.tr.insertText(colonText, from - 1, to));\n            this.close();\n            if (onOpenEmoji) {\n                onOpenEmoji();\n            }\n        };\n        this.handleMentionClick = () => {\n            const { view } = this.props;\n            const { dispatch, state } = view;\n            const { from, to } = state.selection;\n            const mentionText = `@`;\n            dispatch(view.state.tr.insertText(mentionText, from - 1, to));\n            this.close();\n        };\n        this.handleLinkInputKeydown = (event) => {\n            if (!this.props.isActive)\n                return;\n            if (!this.state.insertItem)\n                return;\n            if (event.key === \"Enter\") {\n                event.preventDefault();\n                event.stopPropagation();\n                const href = event.currentTarget.value;\n                const matches = this.state.insertItem.matcher(href);\n                if (!matches && this.props.onShowToast) {\n                    this.props.onShowToast(this.props.dictionary.embedInvalidLink, types_1.ToastType.Error);\n                    return;\n                }\n                this.insertBlock({\n                    name: \"embed\",\n                    attrs: {\n                        href,\n                        component: this.state.insertItem.component,\n                        matches,\n                    },\n                });\n            }\n            if (event.key === \"Escape\") {\n                this.props.onClose();\n                this.props.view.focus();\n            }\n        };\n        this.handleLinkInputPaste = (event) => {\n            if (!this.props.isActive)\n                return;\n            if (!this.state.insertItem)\n                return;\n            const href = event.clipboardData.getData(\"text/plain\");\n            const matches = this.state.insertItem.matcher(href);\n            if (matches) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.insertBlock({\n                    name: \"embed\",\n                    attrs: {\n                        href,\n                        component: this.state.insertItem.component,\n                        matches,\n                    },\n                });\n            }\n        };\n        this.triggerImagePick = () => {\n            if (this.inputRef.current) {\n                this.inputRef.current.click();\n            }\n        };\n        this.triggerLinkInput = (item) => {\n            this.setState({ insertItem: item });\n        };\n        this.handleImagePicked = (event) => {\n            const files = getDataTransferFiles_1.default(event);\n            const { view, uploadImage, onImageUploadStart, onImageUploadStop, onShowToast, } = this.props;\n            const { state, dispatch } = view;\n            const parent = prosemirror_utils_1.findParentNode((node) => !!node)(state.selection);\n            if (parent) {\n                console.log(\" text content\", parent.node);\n                dispatch(state.tr.insertText(\"\", parent.pos, parent.pos + parent.node.textContent.length + 1));\n                insertFiles_1.default(view, event, parent.pos, files, {\n                    uploadImage,\n                    onImageUploadStart,\n                    onImageUploadStop,\n                    onShowToast,\n                    dictionary: this.props.dictionary,\n                });\n            }\n            if (this.inputRef.current) {\n                this.inputRef.current.value = \"\";\n            }\n            this.props.onClose();\n        };\n    }\n    componentDidMount() {\n        if (!SSR) {\n            window.addEventListener(\"keydown\", this.handleKeyDown);\n        }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        return (nextProps.search !== this.props.search ||\n            nextProps.isActive !== this.props.isActive ||\n            nextState !== this.state);\n    }\n    componentDidUpdate(prevProps) {\n        if (!prevProps.isActive && this.props.isActive) {\n            const position = this.calculatePosition(this.props);\n            this.setState(Object.assign({ insertItem: undefined, selectedIndex: 0 }, position));\n        }\n        else if (prevProps.search !== this.props.search) {\n            this.setState({ selectedIndex: 0 });\n        }\n    }\n    componentWillUnmount() {\n        if (!SSR) {\n            window.removeEventListener(\"keydown\", this.handleKeyDown);\n        }\n    }\n    clearSearch() {\n        const { state, dispatch } = this.props.view;\n        const parent = prosemirror_utils_1.findParentNode((node) => !!node)(state.selection);\n        if (parent) {\n            dispatch(state.tr.insertText(\"\", parent.pos, parent.pos + parent.node.textContent.length + 1));\n        }\n    }\n    insertBlock(item) {\n        this.clearSearch();\n        const command = this.props.commands[item.name];\n        if (command) {\n            command(item.attrs);\n        }\n        else {\n            this.props.commands[`create${capitalize_1.default(item.name)}`](item.attrs);\n        }\n        this.props.onClose();\n    }\n    get caretPosition() {\n        const selection = window.document.getSelection();\n        if (!selection || !selection.anchorNode || !selection.focusNode) {\n            return {\n                top: 0,\n                left: 0,\n            };\n        }\n        const range = window.document.createRange();\n        range.setStart(selection.anchorNode, selection.anchorOffset);\n        range.setEnd(selection.focusNode, selection.focusOffset);\n        const rects = range.getClientRects();\n        if (rects.length === 0) {\n            if (range.startContainer && range.collapsed) {\n                range.selectNodeContents(range.startContainer);\n            }\n        }\n        const rect = range.getBoundingClientRect();\n        return {\n            top: rect.top,\n            left: rect.left,\n        };\n    }\n    calculatePosition(props) {\n        const { view } = props;\n        const { selection } = view.state;\n        const startPos = view.coordsAtPos(selection.$from.pos);\n        const ref = this.menuRef.current;\n        const offsetHeight = ref ? ref.offsetHeight : 0;\n        const paragraph = view.domAtPos(selection.$from.pos);\n        if (!props.isActive ||\n            !paragraph.node ||\n            !paragraph.node.getBoundingClientRect ||\n            SSR) {\n            return {\n                left: -1000,\n                top: 0,\n                bottom: undefined,\n                isAbove: false,\n            };\n        }\n        const { left } = this.caretPosition;\n        const { top, bottom } = paragraph.node.getBoundingClientRect();\n        const margin = 24;\n        if (startPos.top - offsetHeight > margin) {\n            return {\n                left: left + window.scrollX,\n                top: undefined,\n                bottom: window.innerHeight - top - window.scrollY,\n                isAbove: false,\n            };\n        }\n        else {\n            return {\n                left: left + window.scrollX,\n                top: bottom + window.scrollY,\n                bottom: undefined,\n                isAbove: true,\n            };\n        }\n    }\n    get filtered() {\n        const { dictionary, embeds, search = \"\", uploadImage } = this.props;\n        let items = block_1.default(dictionary);\n        const embedItems = [];\n        for (const embed of embeds) {\n            if (embed.title && embed.icon) {\n                embedItems.push(Object.assign(Object.assign({}, embed), { name: \"embed\" }));\n            }\n        }\n        if (embedItems.length) {\n            items.push({\n                name: \"separator\",\n            });\n            items = items.concat(embedItems);\n        }\n        const filtered = items.filter((item) => {\n            if (item.name === \"separator\")\n                return true;\n            if (!uploadImage && item.name === \"image\")\n                return false;\n            const n = search.toLowerCase();\n            return ((item.title || \"\").toLowerCase().includes(n) ||\n                (item.keywords || \"\").toLowerCase().includes(n));\n        });\n        return filtered.reduce((acc, item, index) => {\n            if (item.name === \"separator\" && index === 0)\n                return acc;\n            if (item.name === \"separator\" && index === filtered.length - 1)\n                return acc;\n            const prev = filtered[index - 1];\n            if (prev && prev.name === \"separator\" && item.name === \"separator\")\n                return acc;\n            const next = filtered[index + 1];\n            if (next && next.name === \"separator\" && item.name === \"separator\")\n                return acc;\n            return [...acc, item];\n        }, []);\n    }\n    render() {\n        const { dictionary, isActive, uploadImage } = this.props;\n        const items = this.filtered;\n        const _a = this.state, { insertItem } = _a, positioning = __rest(_a, [\"insertItem\"]);\n        return (React.createElement(react_portal_1.Portal, null,\n            React.createElement(exports.Wrapper, Object.assign({ id: \"block-menu-container\", active: isActive, ref: this.menuRef }, positioning),\n                insertItem ? (React.createElement(LinkInputWrapper, null,\n                    React.createElement(LinkInput, { type: \"text\", placeholder: insertItem.title\n                            ? dictionary.pasteLinkWithTitle(insertItem.title)\n                            : dictionary.pasteLink, onKeyDown: this.handleLinkInputKeydown, onPaste: this.handleLinkInputPaste, autoFocus: true }))) : (React.createElement(List, null,\n                    items.map((item, index) => {\n                        if (item.name === \"separator\") {\n                            return (React.createElement(ListItem, { key: index },\n                                React.createElement(\"hr\", null)));\n                        }\n                        const selected = index === this.state.selectedIndex && isActive;\n                        if (!item.title || !item.icon) {\n                            return null;\n                        }\n                        return (React.createElement(ListItem, { key: index },\n                            React.createElement(BlockMenuItem_1.default, { onClick: () => this.insertItem(item), selected: selected, icon: item.icon, title: item.title, shortcut: item.shortcut })));\n                    }),\n                    items.length === 0 && (React.createElement(ListItem, null,\n                        React.createElement(Empty, null, dictionary.noResults))))),\n                uploadImage && (React.createElement(VisuallyHidden_1.default, null,\n                    React.createElement(\"input\", { type: \"file\", ref: this.inputRef, onChange: this.handleImagePicked, accept: \"image/*\" }))))));\n    }\n}\nconst LinkInputWrapper = styled_components_1.default.div `\n  margin: 8px;\n`;\nconst LinkInput = styled_components_1.default(Input_1.default) `\n  height: 36px;\n  width: 100%;\n  color: ${(props) => props.theme.blockToolbarText};\n`;\nconst List = styled_components_1.default.ol `\n  list-style: none;\n  text-align: left;\n  height: 100%;\n  padding: 8px 0;\n  margin: 0;\n`;\nconst ListItem = styled_components_1.default.li `\n  padding: 0;\n  margin: 0;\n`;\nconst Empty = styled_components_1.default.div `\n  display: flex;\n  align-items: center;\n  color: ${(props) => props.theme.textSecondary};\n  font-weight: 500;\n  font-size: 14px;\n  height: 36px;\n  padding: 0 16px;\n`;\nexports.Wrapper = styled_components_1.default.div `\n  color: ${(props) => props.theme.text};\n  font-family: ${(props) => props.theme.fontFamily};\n  position: absolute;\n  z-index: ${(props) => {\n    return props.theme.zIndex + 100;\n}};\n  ${(props) => props.top !== undefined && `top: ${props.top}px`};\n  ${(props) => props.bottom !== undefined && `bottom: ${props.bottom}px`};\n  left: ${(props) => props.left}px;\n  background-color: ${(props) => props.theme.blockToolbarBackground};\n  border-radius: 4px;\n  box-shadow: rgba(0, 0, 0, 0.05) 0px 0px 0px 1px,\n    rgba(0, 0, 0, 0.08) 0px 4px 8px, rgba(0, 0, 0, 0.08) 0px 2px 4px;\n  opacity: 0;\n  transform: scale(0.95);\n  transition: opacity 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275),\n    transform 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\n  transition-delay: 150ms;\n  line-height: 0;\n  box-sizing: border-box;\n  pointer-events: none;\n  white-space: nowrap;\n  width: 300px;\n  max-height: 224px;\n  overflow: hidden;\n  overflow-y: auto;\n\n  * {\n    box-sizing: border-box;\n  }\n\n  hr {\n    border: 0;\n    height: 0;\n    border-top: 1px solid ${(props) => props.theme.blockToolbarDivider};\n  }\n\n  ${({ active, isAbove }) => active &&\n    `\n    transform: translateY(${isAbove ? \"6px\" : \"-6px\"}) scale(1);\n    pointer-events: all;\n    opacity: 1;\n  `};\n\n  @media print {\n    display: none;\n  }\n`;\nexports.default = BlockMenu;\n\n\n//# sourceURL=webpack:///./src/components/BlockMenu.tsx?");

/***/ })

})