webpackHotUpdate("main",{

/***/ "./src/marks/Link.ts":
/*!***************************!*\
  !*** ./src/marks/Link.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst prosemirror_commands_1 = __webpack_require__(/*! prosemirror-commands */ \"./node_modules/prosemirror-commands/dist/index.js\");\nconst prosemirror_state_1 = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\nconst prosemirror_inputrules_1 = __webpack_require__(/*! prosemirror-inputrules */ \"./node_modules/prosemirror-inputrules/dist/index.js\");\nconst Mark_1 = __importDefault(__webpack_require__(/*! ./Mark */ \"./src/marks/Mark.ts\"));\nconst isModKey_1 = __importDefault(__webpack_require__(/*! ../lib/isModKey */ \"./src/lib/isModKey.ts\"));\nconst LINK_INPUT_REGEX = /\\[(.+)]\\((\\S+)\\)/;\nfunction isPlainURL(link, parent, index, side) {\n    if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n        return false;\n    }\n    const content = parent.child(index + (side < 0 ? -1 : 0));\n    if (!content.isText ||\n        content.text !== link.attrs.href ||\n        content.marks[content.marks.length - 1] !== link) {\n        return false;\n    }\n    if (index === (side < 0 ? 1 : parent.childCount - 1)) {\n        return true;\n    }\n    const next = parent.child(index + (side < 0 ? -2 : 1));\n    return !link.isInSet(next.marks);\n}\nclass Link extends Mark_1.default {\n    get name() {\n        return \"link\";\n    }\n    get schema() {\n        return {\n            attrs: {\n                href: {\n                    default: \"\",\n                },\n            },\n            inclusive: false,\n            parseDOM: [\n                {\n                    tag: \"a[href]\",\n                    getAttrs: (dom) => ({\n                        href: dom.getAttribute(\"href\"),\n                    }),\n                },\n            ],\n            toDOM: (node) => [\n                \"a\",\n                Object.assign(Object.assign({}, node.attrs), { rel: \"noopener noreferrer nofollow\" }),\n                0,\n            ],\n        };\n    }\n    inputRules({ type }) {\n        return [\n            new prosemirror_inputrules_1.InputRule(LINK_INPUT_REGEX, (state, match, start, end) => {\n                const [okay, alt, href] = match;\n                const { tr } = state;\n                if (okay) {\n                    tr.replaceWith(start, end, this.editor.schema.text(alt)).addMark(start, start + alt.length, type.create({ href }));\n                }\n                return tr;\n            }),\n        ];\n    }\n    commands({ type }) {\n        return ({ href } = { href: \"\" }) => prosemirror_commands_1.toggleMark(type, { href });\n    }\n    keys({ type }) {\n        return {\n            \"Mod-k\": (state, dispatch) => {\n                if (state.selection.empty) {\n                    this.options.onKeyboardShortcut();\n                    return true;\n                }\n                return prosemirror_commands_1.toggleMark(type, { href: \"\" })(state, dispatch);\n            },\n        };\n    }\n    get plugins() {\n        return [\n            new prosemirror_state_1.Plugin({\n                props: {\n                    handleDOMEvents: {\n                        mouseover: (view, event) => {\n                            if (event.target instanceof HTMLAnchorElement &&\n                                !event.target.className.includes(\"ProseMirror-widget\")) {\n                                if (this.options.onHoverLink) {\n                                    return this.options.onHoverLink(event);\n                                }\n                            }\n                            return false;\n                        },\n                        click: (view, event) => {\n                            if (view.props.editable &&\n                                view.props.editable(view.state)) {\n                                return false;\n                            }\n                            if (event.target instanceof HTMLAnchorElement) {\n                                const href = event.target.href ||\n                                    (event.target.parentNode instanceof HTMLAnchorElement\n                                        ? event.target.parentNode.href\n                                        : \"\");\n                                const isHashtag = href.startsWith(\"#\");\n                                if (isHashtag && this.options.onClickHashtag) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickHashtag(href, event);\n                                    return true;\n                                }\n                                if (this.options.onClickLink) {\n                                    event.stopPropagation();\n                                    event.preventDefault();\n                                    this.options.onClickLink(href, event);\n                                    return true;\n                                }\n                            }\n                            return false;\n                        },\n                    },\n                    handleKeyDown: (view, event) => {\n                        if (view.props.editable &&\n                            view.props.editable(view.state) &&\n                            !isModKey_1.default(event)) {\n                            return false;\n                        }\n                        return false;\n                    },\n                },\n            }),\n        ];\n    }\n    get toMarkdown() {\n        return {\n            open(_state, mark, parent, index) {\n                return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n            },\n            close(state, mark, parent, index) {\n                return isPlainURL(mark, parent, index, -1)\n                    ? \">\"\n                    : \"](\" +\n                        state.esc(mark.attrs.href) +\n                        (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") +\n                        \")\";\n            },\n        };\n    }\n    parseMarkdown() {\n        return {\n            mark: \"link\",\n            getAttrs: (tok) => ({\n                href: tok.attrGet(\"href\"),\n                title: tok.attrGet(\"title\") || null,\n            }),\n        };\n    }\n}\nexports.default = Link;\n\n\n//# sourceURL=webpack:///./src/marks/Link.ts?");

/***/ })

})